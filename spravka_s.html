<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>SPRAVKA_S</title>
	<link rel="stylesheet" href="style.css">

</head>
<body>
	<div class="spravka">
	<div class="spravka_ul">		
			
				<a href="#kd" target="_self">KDirStat</a>
				<a href="#moc"target="_self">MOC</a>
				<a href="spravka2_S.html#subl target="_self"">SUBL</a>
				<a href="spravka3_s.html#form" target="_self">FORM</a>
				<a href="git3_s.html#git" target="_self">GIT3</a>
				<a href="#mysql">MYSQL</a>
				<a href="#lxc">LXC</a>
				<a href="lxc_virt_s.html#lxc2" target="_self">LXC2</a>
				<a href="#tar" target="_self">TAR</a>
				<a href=""></a>		
		
	</div>
	<div class="spravka_s">

		
		<h2 id="kd"> KDirStat</h2>
<p>Кратко: для просмотра размеров директорий и поиска больших файлов можно использовать программу KDirStat. Программа показывает "карту" диска, на которой видны большие файлы в виде больших прямоугольников. Выбрав прямоугольник-файл, его можно удалить.</p>

<br>В Debian 9 пакет с этой программой называется k4dirstat.


<p>Для среды GTK есть Graphical Disk Map. Рисует-то оно так, как надо и... всё. Ни тебе операций над файлами, ни тебе удобства в работе.</p>
=================================================================================================================
<br><h2 id="moc">MOC</h2>
<p>Но сколько людей вспомнят о MOC (Music on Console — Музыка в консоли) или irssi (IRC-клиент)? Оба этих приложения основаны на командной строке и очень полезны (и нетребовательны к ресурсам, если для вас это важно). Вам надоело, что музыка перестаёт играть, когда прерывается работа X-cервера (или вы просто отключаете его)? MOC продолжит проигрывать музыку, поскольку работает как сервер командной строки, или вы можете запустить его вообще без X, через tty. <br>Другая ситуация: ваш X-сервер не работает, вам нужна помощь в его восстановлении, но вы не знаете, как вам с кем-нибудь связаться? С помощью irssi вы можете выйти в IRC (например, чтобы зайти на канал #ubuntu на freenode). Эти приложения не только полезны в тех случаях, когда вы остались без GUI, более того — они имеют огромное количество настроек (цвета, дополнительные функции и т.д.). Я, например, использую специальный скрипт, который передаёт conky информацию из MOC. <br>Можно также написать скрипт, который бы выполнялся после завершения песни и отображал название следующей композиции, помещая его при этом в текстовый файл. Сначала давайте разберёмся с MOC. Чтобы установить его, выполните команду: </p>
<br>sudo apt-get install moc 
<p>Когда установка будет завершена, можно запустить программу командой: 
mocp 
<br>Стандартный вид приложения выглядит так: панель выбора файлов слева, а список воспроизведения справа (сейчас он пуст). Для переключения между панелями используется клавиша Tab. При помощи панели выбора файлов вы просматриваете каталоги с музыкой. <br>Если вы хотите добавить в список воспроизведения весь каталог, просто нажмите Shift+a, чтобы добавить только выделенный файл, нажмите 'a'. <br>Когда загрузится вся музыка и информация из тегов, вы увидите приятный на вид список вашей музыки. А если я хочу послушать определённую песню, мне придётся просматривать весь этот огромный список? Ответ прост — нет. <br>Если вы нажмёте 'g' и введёте имя исполнителя, название песни и т.д., в списке воспроизведения будут показаны только песни, соответствующие запросу, просто выделите нужную строчку и нажмите Enter. <br>С помощью файла ~/.moc/config вы можете настроить внешний вид приложения, включить или выключить режим случайного воспроизведения или повтора и т.д. <br>Я не буду рассказывать о практически бесчисленных настройках (потому что их так много, что я даже не знаю, с чего начать), вы можете просто посмотреть мой файл настроек ~/.moc/config на странице: http://fullcirclemagazine.org/moc-config/ 
Основные управляющие клавиши: </p>P
<br>g — поиск 
<br>пробел — пауза/воспроизведение 
<br>ввод — выбор/воспроизведение выбранного файла 
<br>tab — переключение между панелями выбора файлов <br>и списка воспроизведения 
<br>n — следующая песня 
<br>b — предыдущая песня 
<br>C — очистить список воспроизведения 
<br>A — добавить каталог в список воспроизведения <br<br>>рекурсивно 
<br>a — добавить файл в список воспроизведения 
<br>s — включить режим случайного воспроизведения 
<br>h — вызов справки 
<h2 id="mysql">MSQL</h2>
<h3>Установка и первичная настройка MySQL на Ubuntu 16.04 </h3>
￼ 
Nikolay 
28 октябрь 2016 г. 03:28 
<p>Введение
MySQL - одна из самых распространённых и популярных СУБД с открытым исходным кодом. Установка на новую версию Ubuntu у опытных пользователей не вызывает сложностей, однако новичкам может потребоваться подробная инструкция по настройке.</p>
<h3>Технические требования</h3>
<br>Пользователь с sudo-правами
<br>Ubuntu 16.04 
<h3>Шаг 1. Создание нового пользователя</h3>
<p>Создание нового пользователя подробно описано в руководстве Начальная настройка сервера под управлением ОС Ubuntu.
Системой предусмотрено, что новый аккаунт добавляется в одноименную группу пользователей, поэтому дополнительно необходимо присвоить права администратора. Выполняется это командой:
<br>usermod -aG sudo newuser
<br>Закрепляющий флаг -aG добавляет пользователя в выбранную группу и закрепляет за ним права суперпользователя.
<br>Команды прописываются без символа $, поскольку выполняются от имени root-пользователя. Для дальнейшей установки базы данных потребуется проставлять этот символ – он является указателем для системы, что действия поступают от аккаунта, наделенного правами администратора, но не являющегося им.</p>
<h3>Шаг 2. Обновление индекса пакетов</h3>
<p>Данное действие требуется для установки самых свежих пакетов данных, без которых корректная работа системы не гарантируется ее производителем. При этом в процессе обновления старые и не используемые индексы пакетов будут удалены, чтобы не занимать место на сервере.
Если система Ubuntu 16.04 установлена недавно, данный шаг не требуется. В процессе обновления операционной системы до новой версии всегда происходит переустановка индекса пакетов, что позволяет пользователям работать в обновленной системе. И без очевидных сбоев.
Для обновления необходимо ввести команду:</p>
<br>$ sudo apt-get update
Установка из сети интернет может занять некоторое время. После того как система скачает все пакеты обновлений, вы можете приступать к их установке, прописав команду:
<br>sudo apt-get upgrade
Просмотрев все пакеты, доступные для установки, вам нужно подтвердить обновление, нажав Y (yes – да) и клавишу Enter. Процедура займет некоторое время, но в результате неактуальные сведения будут удалены, а свежие версии займут их место на дисковом пространстве сервера.
<h3>Шаг 3. Установка MySQL</h3>
<p>Установка базы данных на Ubuntu производится быстрее всего менеджером установки приложений apt (Advanced Packaging Tool – программа для установки). И главное преимущество менеджера в том, что он не требует отдельной инсталляция, поскольку входит в состав стандартного пакета программ. Apt позволяет без лишних команд установить то или иное приложение на сервер, к которому смогут в дальнейшем обращаться все пользователи определенной сетевой группы, которой вы дадите доступ.</p>
<p>База данных MySQL устанавливается с помощью менеджера быстрее и проще всего. Поэтому требуется последовательно прописать лишь несколько команд:
<br>$ sudo apt-get install mysql-server
<br>$ sudo mysql_secure_installation
После первой команды система попросит вас создать надежный пароль суперпользователя, который одновременно с этим будет являться и паролем от серверной (не клиентской) версии базы данных. Требования к паролю стандартные: не менее 8 символов, желательно добавить цифры и спецзнаки.
После второй команды система обратится к вам с рядом вопросов, на которые нужно ответить, предварительно введя придуманный ранее пароль суперпользователя от серверной версии MySQL.
Все вопросы связаны с тем, какие сценарии будут подключены в программе, а какие выполняться не будут до тех пор, пока вы сами их не запустите. Некоторые сценарии необходимы в работе, некоторые можно отключить, чтобы они не мешали использованию базы данных.</p>
<h3>Шаг 4. Настройка сценариев</h3>
VALIDATE PASSWORD PLUGIN – это настройка, которая автоматически блокирует и отклоняет те пароли, которые считает небезопасными и простыми. Этот параметр можно отключить, но это не означает, что в программе можно будет устанавливать несложные пароли. Использование базы данных третьими лицами приведет к утечке информации, поэтому все ключевые слова должны быть тщательно продуманы администратором.
<br>Также потребуется выбрать уровень безопасности, который подразумевает два вида паролей: самые надежные и обычные. В первом случае (уровень безопасности 2) – это заглавные и прописные буквы, цифры и спецсимволы одновременно, во втором – буквенно-цифровое слово. Настройка безопасно при принятии сразу же проверяет пароль суперпользователя на надежность, при необходимости предлагает вам его заменить. Если вас пароль устраивает, то можно отказаться, нажав клавишу N.
<br>Все остальные сценарии не вызывают в дальнейшем никаких сложностей и особенностей, поэтому вы можете согласиться с их запуском в штатном режиме клавишей Y и Enter. В результате программа самостоятельно удалит ненадежные тестовые или анонимные аккаунты из доступа к базе, а так же обновит все настройки, чтобы они вступили в силу.</br<br>
<h3>Шаг 5. Заведение пользовательских аккаунтов в базе и самой базы</h3>
<p>Для входа в базу mysql нужно ввести команду:
mysql -u root -p
Далее необходимо создать базу данных, а так же завести в ней пользователей-клиентов, которые к ней будут обращаться. Выполняется это простыми командами:
<br>1.CREATE DATABASE name;
<br>2.GRANT ALL ON name.* TO 'XXX' IDENTIFIED BY 'YYY';
<br>3.QUIT;
<br>name - имя вашей базы данных (латиницей), ХХХ – имя пользователя, УУУ – пароль пользователя.
<br>Для того чтобы вы могли войти в базу под конкретным пользователем, нужно ввести команду:
<br>$ mysql -u XXX -p name
<br>где name – это имя базы данных, а ххх – имя пользователя.
<br>После этого можно пользоваться MySQL с любого компьютера, который находится в той же локальной сети (входит в группу, которым доступна программа), что и компьютер с серверной базой данных.</p>
<h3>Заключение</h3>
Использование базы данных MySQL позволяет создавать, редактировать и удалять сведения, например, таблицы данных, которые в ней будут храниться.
 
MySQL 
========================================
<h2 id="lxc">LXC</h2>

<h3>LXD и Docker</h3>
LXD — инструмент относительно новый: первая версия вышла в свет в 2014 году, когда Docker уже получил широкое распространение и хорошо зарекомендовал себя на практике.
Как и Docker, LXD функционирует на базе LXC. 
<br>При этом cфера применения у двух инструментов совершенно разная: если Docker предназначен для запуска в контейнерах приложений, то LXD — для запуска полноценных операционных систем.
<br>С помощью LXD можно создавать даже не контейнеры в буквальном смысле этого слова, а легковесные виртуальные машины. Чтобы подчеркнуть этот момент и одновременно указать на отличие от других инструментов контейнеризации, авторы многих публикаций называют LXD словом lightvisor (на русский язык его уже переводят как «легковизор»). 
<br>В публикациях Canonical отмечается, что LXD-контейнеры могут работать в 10 раз быстрее, чем традиционные виртуальные машины на базе KVM. 
<br>В LXD предпринята попытка решить целый ряд проблем, с которыми приходится сталкиваться при работе с другими инструментами контейнеризации: продуман механизм динамического управления ресурсами, расширены возможности миграции контейнеров (в том числе и в режиме реального времени), устранены проблемы безопасности. По сравнению с Docker у LXD гораздо шире возможности переконфигурации контейнеров.
<br>LXD оснащён открытым API; имеются клиенты для различных языков программирования. Создан плагин для OpenStack, позволяющий управлять контейнерами с помощью клиента Nova. 
.
<h3>Установка и настройка</h3>
<p>Здесь и далее мы будем описывать особенности работы c LXD на материале Ubuntu 16.04. В этой ОС LXD включён в официальные репозитории и устанавливается стандартным способом:
?
1
<br>apt-get install lxd

<br>Стефан Грабе в своей статье рекомендует в качестве бэкенда для хранения контейнеров использовать файловую систему ZFS. Чтобы работать с ZFS, нужно установить соответствующие пакеты:
?
1
<br>apt-get install zfsutils-linux

<br>Если ZFS вам по тем или иным причинам не подходит, вы можете воспользоваться BTRFS или LVM (подробнее об этом см. здесь).
По завершении установки выполним команду:</p>
?
1
<br>lxd init

<p>Программа настройки задаст несколько простых вопросов, после чего всё будет сконфигурировано автоматически. Подробнее об особенностях настройки LXD можно прочитать в этой статье. </p>
<h3>Создание контейнера</h3>
<p>Все контейнеры в LXD создаются на базе образов. Образы можно получить как из локального, так и из удалённого репозитория. Просмотрим список доступных репозиториев:</p>
?
<br>lxc remote list
 
+-----------------+------------------------------------------+---------------+--------+--------+
|      NAME       |                   URL                    |   PROTOCOL    | PUBLIC | STATIC |
+-----------------+------------------------------------------+---------------+--------+--------+
| images          | https://images.linuxcontainers.org       | lxd           | YES    | NO     |
+-----------------+------------------------------------------+---------------+--------+--------+
| local (default) | unix://                                  | lxd           | NO     | YES    |
+-----------------+------------------------------------------+---------------+--------+--------+
| ubuntu          | https://cloud-images.ubuntu.com/releases | simplestreams | YES    | YES    |
+-----------------+------------------------------------------+---------------+--------+--------+
| ubuntu-daily    | https://cloud-images.ubuntu.com/daily    | simplestreams | YES    | YES    |
+-----------------+------------------------------------------+---------------+--------+--------+

<br>Для первого знакомства с LXD вполне подойдёт локальный репозиторий (local). Запустим в контейнере ОС Ubuntu 16.04:
?
1
l<br>xc launch ubuntu:16.04 container1

<br>В результате выполнения этой команды LXD создаст на базе указанного образа контейнер и запустит его.
Запустить в этом контейнере командную оболочку можно с помощью команды:
?
1
<br>lxc exec container1 /bin/bash

<br>Если нужно просто создать контейнер, но не запускать его, достаточно выполнить команду: 
?
1
<br>lxc init ubuntu:16.04 container1

<p>Для последующего запуска и остановки контейнера используются команды lxc start и lxc stop.
LXC предоставляет хорошие возможности для управления контейнерами «на лету». Вот так, например, можно поместить созданный на основном хосте файл внутрь контейнера:</p>
?
1
<br>lxc file push [путь к файлу на основном хосте] [контейнер]/[путь]

<br>Можно совершить и обратную операцию — загрузить файл из контейнера на основной хост
?
1
<br>$ lxc file pull [контейнер]/[путь]

<br>Можно и редактировать файлы в контейнере напрямую:
?
1
<br>lxc edit [контейнер]/[путь]

Основные команды для создания и запуска контейнеров мы уже рассмотрели; желающих узнать больше отсылаем к подробной статье Стефана Грабе. 
<h3>Управление ресурсами</h3>
<p>Управление изолированными окружениями немыслимо без контроля ресурсов: мы должны предоставить контейнеру достаточное количество ресурсов для работы и в то же время быть уверенными в том, что контейнер не будет потреблять лишних ресурсов, нарушая тем самым работу остальной системы.
В LXD можно выделять контейнерам ресурсы при помощи специального набора команд:</p>
?

<br># устанавливаем лимит памяти
<br>lxc config set container1 limits.memory 512M
 
<br># привязываем контейнер к ядрам CPU
<br>lxc config set container1 limits.cpu 1,3
 
<br># ограничиваем потребление ресурсов CPU
<br>lxc config set container1 cpu.allowance 10%
 
<br># ограничиваем объём используемого контейнером дискового пространства(работает только с&nbsp;ZFS или btrfs)
<br>lxc config set container1 root size 10GB

<p>Более подробно почитать об управлении ресурсами можно в этой статье.
Просмотреть статистику потребления ресурсов для контейнера можно с помощью простой команды:</p>

<br>lxc info container1
 
<br>Name: container1
<br>Architecture: x86_64
<br>Created: 2016/08/16 07:55 UTC
<br>Status: Running
<br>Type: persistent
<br>Profiles: default
<br>Pid: 4110
<br>Ips:
<br>lo:     inet    127.0.0.1
<br>lo:     inet6   ::1
<br>eth0:   inet6   fe80::216:3eff:fe18:faa9    vethA2SCMX
<br>Resources:
<br>Processes: 24
<br>Memory usage:
<br>Memory (current): 48.88MB
<br>Memory (peak): 163.26MB
<br>Network usage:
<br>eth0:
<br>Bytes received: 648 bytes
<br>Bytes sent: 648 bytes
<br>Packets received: 8
<br>Packets sent: 8
<br>lo:
<br>Bytes received: 264 bytes
<br>Bytes sent: 264 bytes
<br>Packets received: 4
<br>Packets sent: 4

<h3>Работа со снапшотами</h3>
<p>В LXD имеется возможность создания снапшотов и восстановления контейнеров из снапшотов. Посмотрим, как это работает на практике (пример взят из интерактивного туториала LXD). 
Внесём некоторые изменения в уже созданный нами контейнер container1:</p>

<br>lxc exec container1 -- apt-get update
<br>lxc exec container1 -- apt-get dist-upgrade -y
<br>lxc exec container1 -- apt-get autoremove &mdash;purge -y

<br>Сделаем снапшот этого контейнера и назовём его, например, new:
?
1
<br>lxc snapshot container1 new

<br>Попробуем что-нибудь «поломать» в нашем первом контейнере:
?
1
<br>lxc exec container1 -- rm -Rf /etc /usr

<br>Поcле этого запустим в нём в нём командную оболочку:

<br>lxc exec container1 -- bash
<br>I have no name!@container1:~#

<br>Выполним команду exit и вернёмся на основной хост. Восстановим работу контейнера container1 из снапшота:
?
1
<br>lxc restore container1 new

<br>Запустим командную оболочку в восстановленном контейнере:

<br>lxc exec container1 -- bash
<br>root@container1:#

<br>Всё работает так же, как раньше!
<p>В приведённом выше примере мы рассмотрели так называемые stateless-снапшоты В LXD есть и другой тип снапшотов  — stateful, в которых сохраняется текущее состояние всех процессов в контейнере. Со stateful-снапшотами связаны ряд интересных и полезных функций.
Чтобы создавать stateful-снапшоты, нам понадобится установить программу CRIU(CheckPoint/Restore in Userspace). C её помощью можно сохранить текущее состояние всех процессов, а затем восстановить их хоть на текущей, хоть на другой машине.
В Ubuntu 16.04 утилита CRIU устанавливается при помощи стандартного менеджера пакетов:</p>

<br>apt-get install criu

<br>После этого можно переходить к созданию снапшотов:
?
1
<br>lxc snapshot container1 snapshot1 --stateful

<br>В некоторых ситуациях такие снапшоты могут оказаться очень полезными. <p>Представим себе, например, что нам нужно перезагрузить сервер, на котором запущены один или несколько контейнеров. Чтобы после перезагрузки не запускать всё заново, а продолжить с прерванного места, достаточно выполнить:

<br># перед перезагрузкой</p>
<br>lxc stop container1 --stateful
 
<br>#после перезагрузки
<br>lxc start container1

<p>На базе stateful-снапшотов реализован механизм «живой» миграции контейнеров, который пока что находится в несколько «сыром» состоянии. 
<h3>Заключение</h3>
<br>LXD представляет собой удобную систему управления контейнерами, обладающую целым рядом полезных функций. Надеемся, что  проект LXD будет успешно развиваться и займёт достойное место в ряду современных инструментов контейнеризации.
<br>Если у вас есть практический опыт использования LXD — добро пожаловать в комментарии. 
<br>Естественно, в рамках одной статьи рассказать обо всех функциях LXD вряд ли возможно. Для желающих узнать больше приводим несколько полезных ссылок:
<br>https://www.stgraber.org/2016/03/11/lxd-2-0-blog-post-series-012/ — цикл статей об LXD в блоге Стефана Грабе;
<br>http://vasilisc.com/lxd-2-0-series — перевод всех статей по предыдущей ссылке на русский язык;
<br>https://insights.ubuntu.com/2016/04/19/directly-interacting-with-the-lxd-api/ — статья-введение в LXD API;
<br>https://www.openstack.org/summit/vancouver-2015/summit-videos/presentation/lxd-vs-kvm — видеозапись доклада о перспективах использования LXD в OpenStack. 
<br>Андрей Емельянов 16 августа 2016 Теги: контейнеры</p>
=================================================================================================
<h1 id="tar">Для распаковки tar-архивов через командную строку используется утилита tar.</h1>
<p>Полезно знать, что архивы в формате tar имеют расширение файлов .tar. Также в Linux распространены архивы, которые имеют дополнительное сжатие другими программами. Например, архивы .tar.bz2, .tar.gz и другие. Все эти архивы можно распаковать утилитой tar.</p>
<h2>Распаковка tar</h2>
<br>Для распаковки архива в формате .tar в текущую директорию выполните команду:
<br>tar xvf archive.tar
<br>Распаковка tar.bz2, tar.bzip2, tbz2, tb2, tbz
<br>tar xvjf archive.tar.bz2
<br>Распаковка tar.xz, txz
<br>tar xvJf archive.tar.xz
<br>Распаковка tar.gz, tgz
<br>tar xvzf archive.tar.gz
<h2>Распаковка tar.lzma</h2>
<br>tar --lzma -xvf archive.tar.lzma
<br>Пояснение опций
<br>x — распаковать архив.
<br>v — Verbose-режим (вывод на экран дополнительной информации во время распаковки).
<br>f — выполнить распаковку архива из файла.
<br>j — вызвать bzip2 для распаковки архива.
<br>z — вызвать gzip
<br>J — вызвать xz 
<br>Распаковка в определенную директорию
<br>Чтобы распаковать архив в определенную директорию используется опция -C или --directory, например:
<br>tar xvf archive.tar -C /to/directory
<br>Примечание: директория должна существовать.
<h2>Заключение</h2>
VМы рассмотрели базовый набор команд, который можно использовать для распаковки различных видов tar-архивов. Существуют также еще некоторые типы архивов, но они менее распространены.

	</div>
</div>
	
</body>
</html>